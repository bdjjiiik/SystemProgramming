### Задача 2.1
Напишите программу, чтобы узнать, когда закончится time_t.

### Задача 2.2
Посмотрите на сегменты в исполняемом файле.
1. Скомпилируйте программу "hello world", запустите `ls -l` для исполняемого
файла, чтобы получить его общий размер, и запустите size, чтобы получить размеры сегментов
внутри него.
2. Добавьте объявление глобального массива из 1000 int, перекомпилируйте и
повторите измерения. Обратите внимание на различия.
3. Теперь добавьте начальное значение в объявление массива (помните, C не заставляет
вас указывать значение для каждого элемента массива в инициализаторе). Это переместит
массив из сегмента BSS в сегмент данных. Повторите измерения. Обратите внимание на
различия.
4. Теперь добавьте объявление большого массива в локальную функцию. Объявите
второй большой локальный массив с инициализатором. Повторите измерения. Данные
определены локально внутри функции, хранящейся в исполняемом файле? Какая разница,
инициализирован он или нет?
5. Какие изменения происходят с размерами файлов и сегментов, если вы компилируете
для отладки? Для максимальной оптимизации?
Проанализируйте результаты , чтобы убедиться, что:
    - сегмент данных хранится в объектном файле
    - сегмент BSS не сохраняется в объектном файле (за исключением примечания к его
требованиям к размеру времени выполнения)
    - текстовый сегмент больше всего подвержен оптимизации
    - На размер файла a.out влияет компиляция для отладки, но не на сегменты.

### Задача 2.3
Скомпилируйте и запустите тестовую программу, чтобы определить примерное
расположение стека в вашей системе:
```
#include <stdio.h>
int main() {
  int i;
  printf("The stack top is near %p\n", &i);
  return 0;
}
```
Найдите расположение сегментов данных и текста, а также кучу внутри сегмента данных,
объявив переменные, которые будут помещены в эти сегменты, и распечатав их адреса.
Увеличьте размер стека, вызвав функцию и объявив несколько больших локальных массивов.
Какой сейчас адрес вершины стека?

### Задача 2.4
Исследовать стек процесса.

### Задача 2.5
Известно, что при вызове процедур и возврате из них процессор использует стек. Можно
ли в такой схеме обойтись без счетчика команд (IP), используя вместо него вершину стека? Свой ответ обоснуйте и покажите пример(ы).

